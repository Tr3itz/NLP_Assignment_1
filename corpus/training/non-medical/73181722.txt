Programming languages are typically created by designing a form of representation of a computer program, and writing an implementation for the developed concept,  usually an interpreter or compiler. Interpreters are designed to read programs, usually in some variation of a text format, and perform actions based on what it reads, whereas compilers convert code to lower level.


== Design ==
In programming language design, there are a wide variety of factors to consider. Some factors may be mutually exclusive (e.g. security versus speed). It may be necessary to consider whether a programming language will perform better interpreted, or compiled, if a language should be dynamically or statically typed, if inheritance will be in a language, and the general syntax of the language. Many factors involved with the design of a language can be decided on by the goals behind the language. It's important to consider the target audience of a language, its unique features and its purpose. It is good practice to look at what existing languages lack, or make difficult, to make sure a language serves a purpose. 
Various experts have suggested useful design principles:

As the last paragraph of an article published in 1972, Tony Hoare has provided some general advice for any software project:“So my advice to the designers and implementer of software of the future is in a nutshell:
do not decide exactly what you are going to do until you know how to do it;
and do not decide how to do it until you have evaluated your plan against all the desired criteria of quality.
And if you cannot do that, simplify your design until you can.”At a SIGPLAN symposium in 1973, Tony Hoare discussed various language aspects in some detail. He also identifies a number of shortcomings in (then) current programming languages.“a programming language is a tool which should assist the programmer in the most difficult aspects of his art,
namely program design, documentation, and debugging.”“objective criteria for good language design may be summarized in five catch phrases:
simplicity, security, fast translation, efficient object code, and readability.”
"It is absurd to make elaborate security checks on debugging runs, when no trust is put in the results, and then remove them in production runs, when an erroneous result could be expensive or disastrous. What would we think of a sailing enthusiast who wears his life-jacket when training on dry land but takes it off as soon as he goes to sea?"At IFIP Congress 1974, Niklaus Wirth, designer of Pascal, presented a paper "On the design of programming languages”. Wirth listed a number of conflicting suggestions, most notably that a language should be easy to learn and use, it should be usable without new features being added, the compiler should generate efficient code, a compiler should be fast, and that a language should be compatible with libraries, the system it is running on, and programs written in other languages.


== Implementation ==


=== Interpreters ===

An interpreter is a program that reads another program, typically as text,  as seen in languages like Python. Interpreters read code, and produce the result directly. Interpreters typically read code line by line, and parse it to convert and execute the code as operations and actions.


=== Compilers ===

Compilers are programs that read programs, also usually as some form of text, and converts the code into lower level machine code or operations. Compiled formats generated by compilers store the lower level actions as a file.  Compiled languages converted to machine code, tend to be a lot faster, as lower level operations are easier to run, and outcomes can be predicted and compiled ahead of time. 


== Process ==
Processes of making a programming language may differ from developer to developer, however, here is a general process of how one might create a programming language, that includes common concepts.

Design: Design aspects are considered, such as types, syntax, semantics, and library usage to develop a language.
Consideration: Syntax, implementation, and other factors are considered. Languages like Python interpret code at runtime, whereas language like C++ follow an approach of basing it's compiler off of C's compiler.
Create an implementation: A first implementation is written. Compilers will convert to other formats, usually ending up as low-level as assembly, even down to binary.
Improve your implementation: Implementations should be improved upon. Expand the programming language, aiming for it to have enough functionality to bootstrap, where a programming language is capable of writing an implementation of itself.
Bootstrapping: If using a compiler, a developer may use the process of bootstrapping, where a programming language is rewritten in itself. This is good for bug checking, and proving its capability. Bootstrapping also comes with the benefit of only needing to program the language in itself from there-on.


== References ==